{"tagline":"essential unit test framework","body":"wru :: JavaScript tests have never been that easy\r\n=================================================\r\n\r\n*wru* is an **essential general purpose test framework** compatible with **web** environment, [node.js](http://nodejs.org/), [Rhino](http://www.mozilla.org/rhino/), and now [PhantomJS](http://www.phantomjs.org/) too.\r\n\r\n\r\nfeatures\r\n--------\r\n\r\n  * **runs in both client and server environments**, compatible with html files, node.js, Rhino, PhantomJS, and JavaScriptCore.\r\n  * **both synchronous and asynchronous tests** in an absolutely intuitive way\r\n  * **ES5 and JS.next ready**, compatible with `\"use strict\"` directive which means no `with` statements, `eval`, or misused `this` references\r\n  * **easy**, probably the easiest way to test JS code out there thanks to its simplified API: `test`, `assert`, `async`, and `log` ... you already remember \"*all of them*\", isn't it?\r\n  * **unobtrusive** and **self defensive**, since everything that could possibly change in such dynamic environment as JS is, is \"*sandboxed*\" inside the *wru closure*. This means no matter how \"*nasty*\" your code is, *wru* won't pollute or change the global environment, neither it will rely in native *constructor.prototypes* changes (`Array.prototype.push = ...` or `Object.prototype.hasOwnProperty = ...`? not a problem!)\r\n  * **cursor included in both web and console** ... you gonna realize how much \"[THE CURSOR](http://www.3site.eu/cursor/)\" is important, specially to understand if your test is **stuck** or simply \"*waiting for*\" ... cursor is working in both Unix and OSX consoles (unfortunately PhantomJS does not support the cursor while jsc does not support timers at all)\r\n  * **tiny**, even if it's not important in tests world, *wru* fits into about 2Kb (1.2Kb *minzpped*) which means not much to fix or change here, just a simple, reliable, and essential framework for your tests\r\n  * **under your control**, since there is absolutely **no magic behind the *wru* scene**. You assert what you want, you async what you need, you describe what's needed, and you are *ready to go* in less than 5 minutes\r\n\r\nIf you can't believe it check [html](https://github.com/WebReflection/wru/blob/master/test/test.html), [node.js](https://github.com/WebReflection/wru/blob/master/test/testnode.js), [Rhino](https://github.com/WebReflection/wru/blob/master/test/testrhino.js), or [PhantomJS](https://github.com/WebReflection/wru/blob/master/test/phantom.js) test and see how *wru* does work ;-)\r\n\r\n\r\ncompatibility\r\n-------------\r\n\r\n*wru* is compatible with basically all possible browsers out there included **IE5.5**, **IE6**, **IE7**, **IE8**, **IE9**, **IE10**, **Chrome**, **Firefox**, **Safari**, **Webkit** based, **Mobile Browsers**, and **Opera**.\r\n\r\nOn server side *wru* is compatible with latest **node.js**, **Rhino**, **PhantomJS**, and **JavaScriptCore** versions. I swear if *I find an easy way to* easily *test Spider/Iron/JagerMonkey I will support them* too.\r\n\r\n\r\nhow to test wru\r\n---------------\r\n\r\nThe simplest way to test wru is to use [template.html](https://raw.github.com/WebReflection/wru/master/build/template.html) for **web** tests or [template.js](https://raw.github.com/WebReflection/wru/master/build/template.js) for **node**, **rhino**, and **jsc** tests or [template.phantom.js](https://github.com/WebReflection/wru/blob/master/build/template.phantom.js) for **PhantomJS** tests.\r\n\r\nWith these 3 options you don't even need to fork or download the entire repository ... but if you do that ...\r\n\r\nFrom *wru* root directory, simply run these commands accordingly with what you want to test:\r\n\r\n    // node.js test\r\n    node test/test.js\r\n    \r\n    // Rhino\r\n    java -jar builder/jar/js.jar test/test.js\r\n\t\r\n    // PhantomJS test\r\n    phantomjs test/phantom.js\r\n    \r\n    // JavaScriptCore test\r\n    jsc test/test.js\r\n    \r\n    // web (through Mac OSX but you can open test.html with any browser)\r\n    open test/test.html\r\n\r\n**PhantomJS** supports tests for both plain JavaScript in a blank page, or any url adding it as argument.\r\n\r\n\t// PhantomJS test on about:blank\r\n\tphantomjs build/template.phantom.js\r\n\t\r\n    // PhantomJS test on any url\r\n    phantomjs build/template.phantom.js \"http://yourwebsite.com\"\r\n\r\n**PhantomJS** tests should always starts when the DOM has been already parsed.\r\n\r\n**JavaScriptCore** does not implement (yet) setTimeout and setInterval so it's not possible to test via `async()` calls.\r\n\r\nIf you forked the project, you made some change, and you want to **rebuild wru**, this is all you have to do:\r\n\r\n    // still inside wru folder\r\n    python builder/build.py\r\n    \r\n    // or now with node\r\n    node builder/build.js\r\n\r\nAfter the build process is finished, no more than 3 seconds with forced waiting time included to read stats if build has been *double-clicked*, you should be able to run again the test for your own environment.\r\n\r\nPlease bear in mind **JSbuilder.(js|py)** works with **node-js 0.4+** or **Python < 3** (2.6 or 2.7 are fine) so be sure you have it (you should by default on Mac or Linux).\r\n\r\n\r\nwru basics\r\n----------\r\n\r\n    // probably all you need as \"one shot\" test\r\n    wru.test({\r\n        name: \"Hello wru!\",\r\n        test: function () {\r\n            wru.assert(\"it works!\", 1);\r\n        }\r\n    });\r\n    \r\n    // for multiple tests ... pass an Array\r\n    wru.test([{\r\n        name: \"test #1\",\r\n        setup: function () {\r\n            // setup before the test\r\n        },\r\n        test: function () {\r\n            // async test example\r\n            setTimeout(wru.async(function () {\r\n                wru.assert(\"executed\", true);\r\n            }), 1000);\r\n        },\r\n        teardown: function () {\r\n            // clean up after the test\r\n        }\r\n    },{\r\n        name: \"test #2\",\r\n        test: function () {\r\n            // do other stuf here\r\n        }\r\n    }]);\r\n\r\nTo know more about *wru* possibilities ... please keep reading ;-)\r\n\r\n\r\nwru API\r\n=======\r\n\r\nThere are truly few things you need to know, and even less properties you need to configure!\r\n\r\n\r\nmethods\r\n-------\r\n\r\n  * `test(object)` or `test([object, ..., object])` to execute one or more tests. A generic test object may have one or more properties:\r\n      * `test` property, as **function**, to execute the test with one or more `wru.assert()` or `wru.async()` calls. **optional** but recommended\r\n      * `name` or `description` property, as **string**, to have visual knowledge of the current test **optional**\r\n      * `setup` property, as **function**, that will be executed right before the test: **optional**\r\n      * `teardown` property, as **function**, that will be executed right after the test: **optopnal**\r\n  * `assert(\"description\", truishOrFalsyValue)` to manually assert whatever you want where **description is optional** (but suggested) and the assertion is compatible with *truish* or *falsy* values. You are in charge of strictly compared results if necessary by *===* operator, nothing new to learn here\r\n  * `async(\"description\", callback, timeout)` to tell *wru* that a test will be executed at some point later and where **both description and timeout are optionals**\r\n  * `log(anything, forceFallback)` the equivalent of *console.log(obj)* where supported, the equivalent of *alert()* or *print()* if the *forceFallback* flag is set to true (or better, *truish*)\r\n\r\n\r\nproperties\r\n----------\r\n\r\n  * `random`, as `true` or `false`, to make tests order execution random (by default `false`)\r\n  * `node` on **web version only** to set a different node from the default one (which is an element with `id == \"wru\"`or the `document.body` or the `document.documentElement` if `body` is not present yet)\r\n\r\n\r\ntest properties\r\n---------------\r\nEach test can be either an object or, if you are that lazy typer, a function.\r\n\r\n  * `name` as test *title* or *test name*, if the test is a function the function name (expression or declared) will be used where available, anonymous otherwise.\r\n  * `setup` as function to do something before the test is executed. Bear in mind every test will receive a freshly baked object as argument, from setup, to test, and teardown, the same object. Use it if you need.\r\n  * `test` as function to execute if the test is not a function itself. Receives the shared object per test as first argument.\r\n  * `teardown` as function to do something after the test is executed. Receives the same shared object setup and test receive as argument.\r\n\r\n\r\nhow does wru work\r\n=================\r\n\r\nfollowing a list of explained tasks that are possible with *wru*\r\n\r\n\r\nsynchronous tests and wru.assert()\r\n----------------------------------\r\nEvery test **may** have one or more `wru.assert()` calls inside. The method itself accepts one or two arguments. Following a sequence of valid operations.\r\n\r\n    // the test object ...\r\n    {\r\n        name: \"existance test\",\r\n        test: function () {\r\n            \r\n            // example only: if next property is not\r\n            // null, undefined, 0, false, \"\", or NaN\r\n            // the assertion will pass the test\r\n            wru.assert(\"callback exists\", window.onload);\r\n            \r\n            // if necessary, assertion can be strict without problems\r\n            wru.assert(\r\n                \"it is a callback\",\r\n                typeof window.onload === \"function\"\r\n            );\r\n            \r\n            // the description is visually useful\r\n            // if the test fails but it's not mandatory\r\n            // next example is still valid, no description\r\n            wru.assert(\"isArray\" in Array);\r\n            \r\n            // if a condition supposes to be truish\r\n            // wru.assert can make test life easier\r\n            // returning the asserted value\r\n            if (wru.assert(\"defineProperty\" in Object)) {\r\n                wru.assert(\r\n                    Object.defineProperty({}, \"_\", {value: true})._\r\n                );\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n\r\nasynchronous tests and wru.async()\r\n----------------------------------\r\nEvery test is performed synchronously unless there is one or more `wru.async()` calls. In latter case all tests after the current one will be waiting for the asynchronous call to be executed.\r\nWhen it happens, if the asynchronous call performed one or more assertions, the framework keep going without requiring any extra step: **is that easy!**\r\n\r\n    // the test object ...\r\n    {\r\n        name: \"load content\",\r\n        test: function () {\r\n            // asynchronous test example\r\n            \r\n            // this will be synchronous\r\n            wru.assert(\"condition accepted\", true);\r\n            \r\n            // this will be asynchronous\r\n            var xhr = new XMLHttpRequest;\r\n            xhr.open(\"get\", \"file.txt\", true);\r\n            xhr.onreadystatechange = wru.async(function () {\r\n                if (this.readyState === 4) {\r\n                    \r\n                    // only on readyState 4 there is an assertion\r\n                    wru.assert(\"text is not empty\", this.responseText.length);\r\n                    \r\n                    // if necessary, async call can be nested\r\n                    setTimeout(wru.async(function () {\r\n                        wru.assert(\r\n                            \"DOM changed in the meanwhile\",\r\n                            docment.body.innerHTML != storedLayout\r\n                        );\r\n                    }, 500));\r\n                }\r\n            });\r\n            xhr.send(null);\r\n            \r\n            // this will be performed regardless\r\n            wru.assert(\"something else to check\", 1);\r\n        }\r\n    }\r\n\r\nIn above example, the `onreadystatechange` function may be executed many times on different `readyState`. The *wru* logic cannot care less about it since an asynchronous callback is considered *done* when **at least one assertion has been performed**.\r\nIf this does not happen the internal `TIMEOUT` constant, by default 10 seconds, will kill the procedure.\r\nYou have to admit there is no reason to create an asynchronous test without performing some assertion inside the callback ... and this is where *wru* is smart.\r\nIf many assertions have been defined and one of them is not reached is most likely because there was an error or a failure in the test.\r\n*wru* tracks all tests without problems so forget things such `lib.expectedAssertions(3)` and \"*friends*\" ... you really may not need that!\r\n\r\n\r\nthe temporary object\r\n--------------------\r\n\r\nIf needed, every `setup`, `test`, or `teardown` function will receive a \"*freshly new backed*\" object for the current test.\r\nThis can be handy to store some reference or value on `setup`, use them during the `test`, and drop them during the `teardown` if necessary.\r\n\r\n    // the test object ...\r\n    {\r\n        name: \"tmp object all over\",\r\n        setup: function (tmp) {\r\n            tmp.global = window;\r\n            tmp.global.random = Math.random();\r\n        },\r\n        test: function (tmp) {\r\n            wru.assert(\r\n                tmp.global === window // true\r\n            );\r\n            wru.assert(\r\n                typeof tmp.global.random == \"number\" // true again\r\n            );\r\n        },\r\n        teardown: function (tmp) {\r\n            delete tmp.global.random;\r\n            delete tmp.global;\r\n        }\r\n    }\r\n\r\n\r\nthe build process\r\n=================\r\n\r\n*wru* is based on [javascript-builder](http://code.google.com/p/javascript-builder/) which is able to aggregate distributed files in order to produce the final library/framework even if the source/JS logic is split in more files.\r\n\r\nThis is the *wru* case, where some file is dedicated for web environment rather than console/shell one.\r\nIf you fork the project and you make some change/improvement, first of all let me know :-), secondly remember to re-build the script.\r\nThis is the list of files actually created by *wru build process* inside the *build* folder:\r\n\r\n  * **wru.console.max.js** is the full script console/shell related, suitable for *node.js* or *rhino* tests\r\n  * **wru.console.js** is the minified version of the precedent one with `wru.debug()` stripped out\r\n  * **wru.dom.js** is the full script DOM related, suitable for *web* and *browsers*\r\n  * **wru.min.js** is the minified version of the precedent one with `wru.debug()` stripped out\r\n\r\n`wru.debug()` is a method used to export, track, test, or change internals. You should never use this method unless strictly necessary but it's there for debugging purpose.\r\n`wru.debug()` is automatically removed from built versions so that no evaluation of internals can be possible.\r\n\r\nIf you want to have an overall view of the framework check already built output since if not familiar with this build process it may be hard at the beginning.\r\n\r\nThis is the [HTML version](https://github.com/WebReflection/wru/blob/master/build/wru.dom.js), and this is the [console one](https://github.com/WebReflection/wru/blob/master/build/wru.console.max.js), you will notice things make sense there since the order is specified in the [build.py](https://github.com/WebReflection/wru/blob/master/builder/build.py) file.\r\n\r\nPlease remember all you have to do to build *wru* is this call in the *wru* project root\r\n\r\n    python builder/build.py\r\n\r\n\r\nwru against others\r\n==================\r\n\r\nOther tests frameworks may offer more than what *wru* does but this rarely comes for free.\r\nSome of them may have such complicated/articulated logic that it may happens is the test framework itself that's failing rather than your code.\r\nAlso you need to read a lot of documentation and most likely to obtain something already possible with *wru*.\r\nI am not saying *wru* is the best test framework out there, I am just saying you should consider your requirements before you chose a test framework ;-)\r\nIn any case, *wru* aim is to make any sort of test simplified and under control.\r\n\r\nAs example: \"*do you really need so much 'magic' to perform these tasks?*\"\r\n\r\n    // rather than specify expected arguments\r\n    // via magic/complicated operations\r\n    function (a, b, c) {\r\n        wru.assert(\"received numbers\",\r\n            typeof a == \"number\"\r\n            &&\r\n            typeof b == \"number\"\r\n            &&\r\n            typeof c == \"number\"\r\n        );\r\n    }\r\n    \r\n    // rather than specify returned values\r\n    // via magic/complicated operations\r\n    wru.assert(typeof callbac() != \"undefined\");\r\n    \r\n    // did you know the console object\r\n    // may have already an assert() method\r\n    // since that's basically all you need?\r\n    wru.assert(\r\n        \"if true, I can get rid of wru since all I need is 'assert'\",\r\n        \"assert\" in console\r\n    );\r\n    \r\n    // the only reason wru may be handy is the\r\n    // cross platform/environment compatibility\r\n    // and its async method interlaced with\r\n    // current environment layout (HTML or shell/console/bash)\r\n    wru.assert(\"oh come on but this is so easy!\", 1);\r\n\r\nJust give it a try ;-)\r\n\r\n\r\nHTML VS console\r\n===============\r\n\r\n*wru* core functionality is exactly the same in both environments ... it cannot be easier to maintain, imo.\r\nHowever, there are few substantial differences between HTML results and those shown in the console\r\n\r\n\r\nHTML tests\r\n----------\r\n\r\n  * based on classes, easily to customize via [CSS](https://github.com/WebReflection/wru/blob/master/test/wru.css)\r\n  * differential colors accordingly with test results: green if successful, red if failed, black if cryptical (e.g. unmanaged exceptions)\r\n  * failures or errors are not shown by default, **one click** to see the list of problems in any of those non green tests\r\n  * summary on top, no need to scroll 'till the end of the document to understand how it was. A nice summary with all passed, failed, or unmanaged errors test is shown on top\r\n\r\n\r\nconsole tests\r\n-------------\r\n\r\n  * based on `stdout`\r\n  * differential prefixes accordingly with test results: `[OK]` if successful, `[FAILURE]` if failed, `[ERROR]` if cryptical (e.g. unmanaged exceptions)\r\n  * failures and errors are always listed in the output\r\n  * summary always at the end of the test\r\n\r\n\r\nI need a setup per each test!\r\n=============================\r\n\r\nSure you do :-)\r\n\r\n    // just create a simple wrapper before your tests\r\n    // to fully automate the procedure\r\n    wru.test = (function (test) {\r\n        \r\n        // we got a closure here, do whaveter you want!\r\n        function whateverSetupIsNeeded(tmp) {\r\n            // do setup stuff\r\n        }\r\n        \r\n        return function (testObjects) {\r\n            // be sure it's an array, convert otherwise\r\n            testObjects = [].conca(testObjects);\r\n            \r\n            // per each object\r\n            for (var\r\n                // reassign the setup if present\r\n                reassign = function (setup) {\r\n                    testObjects[i].setup = function (tmp) {\r\n                        whateverSetupIsNeeded(tmp);\r\n                        setup && setup(tmp);\r\n                    };\r\n                },\r\n                i = testObjects.length; i--;\r\n                reassign(testObjects[i].setup)\r\n            );\r\n            \r\n            // invoke wru.test() which is self bound\r\n            test(list);\r\n            \r\n            // that's pretty much it\r\n        };\r\n        \r\n    }(wru.test));\r\n\r\nSimilar technique if you need same teardown call per each test.\r\n\r\n\r\nI need other edge cases too !\r\n=============================\r\n\r\nThe cool part is that being simple, *wru* is also highly customizable.\r\nPlease keep an eye in the [solutions.html](https://github.com/WebReflection/wru/blob/master/test/solutions.html) file.\r\nI will try to update it as soon as some *request or edge case* comes up.\r\n\r\n\r\nwrap it if you want\r\n===================\r\n\r\nIf you think *wru* is too simple, you still have a chance to improve it wrapping its basic methods and create something wonderful out of it.\r\nArguments automations? Returned values? Expected number of calls per callback?\r\n\r\nThe *wru* cross environment core is easy to hack for anybody, check [wru.js](https://github.com/WebReflection/wru/blob/master/src/wru.js) and your are already half way through ;-)\r\n\r\n\r\nlicense\r\n=======\r\n\r\n*wru* general purpose test framework and the rest of the project is under Mit Style License\r\n\r\n    Copyright (C) 2011 by Andrea Giammarchi, @WebReflection\r\n    \r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n    \r\n    The above copyright notice and this permission notice shall be included in\r\n    all copies or substantial portions of the Software.\r\n    \r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n    THE SOFTWARE.\r\n\r\n\r\nOT: some fun during wru development\r\n-----------------------------------\r\n\r\nIf you check the built source you will realize that a `wru.test()` lifecycle is between a call to internal `isGonnaBeLegen()` function, passing through the `waitForIt` variable if some asynchronous call has been required, and ending up into the `Dary()` callback.\r\n\r\nI know you don't care but at least now you know how is the `wru.test()` lifecycle :{D","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Wru"}